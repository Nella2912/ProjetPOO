/**
 * 
 * @author Hornella Fosso - Kahina Lounaci
 *
 */
public class AlignementMultiple {

	public static void main(String[] args) throws Exception {
		/*
		// TODO Auto-generated method stub
		String index1 = "881726";
		String index2 = "793074";
		String s1;
		s1 = "GACGAACGCTGGCGGCGTGCCTAATACATGCAAGTCGAGCGGATTCATCCTTCGGGATGGGTTAGCGGCGGACGGGTGAGTAACACGTAGGCAACCTGCCTGCAAGTCCGGGATAACTAACGGAAACGTTAGCTAATACCGGATACGCGGTTGGATCGCATGATCCGATCGGGAAAGACGGCGCAAGCTGCCACTTGTAGATGGGCCTGCGGCGCATTAGCTAGTTGGTGGGGTAACGGCTCACCAAGGCGACGATGCGTAGCCGACCTGAGAGAGTGATCGGCCACACTGGGACTGAGACACGGCCCAGACTCCTACGGGAGGCAGCAGTAGGGAATCTTCCGCAATGGACGCAAGTCTGACGGAGCAACGCCGCGTGAGTGATGAAGGTTCTCGGATCGTAAAGCTCTGTTGCCAGGGAAGAACGCTCGGGAGAGTAACTGCTCTCGAGGTGACGGTACCTGAGAAGAAAGCCCCGGCTAACTACGTGCCAGCAGCCGCGGTAATACGTAGGGGGCAAGCGTTGTCCGGAATTATTGGGCGTAAAGCGCGCGCAGGCGGTCGATTAAGTTTGGTGTTTAAGCCCGGGGCTCAACCCCGGTTCGCACTGAAAACTGATCGACTTGAGTGTAGGAGAGGAAAGTGGAATTCCACGTGTAGCGGTGAAATGCGTAGAGATGTGGAGGAACACCAGTGGCGAAGGCGACTTTCTGGCCTATAACTGACGCTGAGGCGCGAAAGCGTGGGGAGCAAACAGGATTAGATACCCTGGTAGTCCACGCCGTAAACGATGCATGCTAGGTGTTAGGGGTTTCGATACCCTTGGTGCCGAAGTCAACACAGTAAGCATGCCGCCTGGGGAGTACGGTCGCAAGACTGAAACTCAAAGGAATTGACGGGGACCCGCACAAGCAGTGGAGTATGTGGTTTAATTCGAAGCAACGCGAAGAACCTTACCAGGTCTTGACATCCCCCTGAATCCTCTAGAGATAGAGGCGGCCCTTCGGGGACAGGGGAGACAGGTGGTGCATGGTTGTCGTCAGCTCGTGTCGTGAGATGTTGGGTTAAGTCCCGCAACGAGCGCAACCCTTGATCGTAGTTGCCAGCACTTCGGGTGGGCACTCTAGGATGACTGCCGGTGACAAACCGGAGGAAGGCGGGGATGACGTCAAATCATCATGCCCCTTATGACCTGGGCTACACACGTACTACAATGGCCGGTACAACGGGCTGCGAAGCCGCGAGGTGGAGCCAATCCCAGAAAGCCGGTCTCAGTTCAGATTGCAGGCTGCAACTCGCCTGCATGAAGTCGGAATTGCTAGTAATCGCGGATCAGCATGCCGCGGTGAATACGTTCCCGGGTCT";
		String s2;
		s2 = "GAATGAACGCTGGCGGCGTGCTTAATAATGCAAGTCGAGCGCGTAGCAATACGAGCGGCGCACGGGTGCGTAACACGTAGGTCATCTGCCTCTAGGTCGGGGATAACTGCGGGAAACTGCAGCTAATACCCGATGATATCGAGAGATCAAAGCTTCGGTGCCTAGAGAGGAGCCTGCGGCTCATTAGCTAGTTGGTGGGGTAACGGCCTACCAAGGCCACGATGAGTAGCCGGCCTGAGAGGGCGATCGGCCACACTGGAACTGAGACACGGTCCAGACTCCTACGGGAGGCAGCAGTAGGGAATATTGGGCAATGGGCGAAAGCCTGACCCAGCAACGCCGCGTGAGTGATGAAGCCTTTCGGGGTGTAAAGCTCTTTTGGCAGGGACGAATCAATGACGGTACCTGCGTAATAAGCCCCGGCTAACTCCGTGCCAGCAGCCGCGGTAATACGGGGGGGGCAAGCGTTATTCGGAATTACTGGGCGTAAAGCGCGCGTAGGCGGCTTCTTAAGTCGGGTGTTTAATGTCGGGGCTCAACTCCGGCGCTGCACTCGATACTGGGAGGCTAGAGTACTCGAGAGGAAAGCGGAATTCCTAGTGTAGCGGTGAAATGCGTAGATATTTAGGAGGAACACCAGTGGCGAAGGCGGCTTTCTGGAGAGTAACTGACGCTCAGAGCGCGAAAGCCAGGGGATCGAACGGGATTAGATACCCCGGTAGTCCTGGCTGTAAACGATGGGTACTAGATGTCGCCGGTATCAATCCCGGCGGTATCGTCGCTAACGCATTAAGTACCCCGCCTGGGGAGTACGCTCGCAAGAGTGAAACTCAAAGGAATTGACGGGGGCCCGCACAAGCGGTGGAGCATGTGGTTTAATTCGATGCAACGCGAAGAACCTTACCTGGACTTGACATACCTCGGACCGGACCTAGAGATAGGACCTTCTCCCGTAAGGGAGCCGGGGATACAGGTGCTGCATGGCTGTCGTCAGCTCGTGTCGTGAGATGTTGGGTTAAGTCCCGCAACGAGCGCAACCCCCATCCCTAGTTGCCAGCGAGTCATGTCGGGAACTCTAGGGAGACTGCCGTTGATAAAACGAGAGGAAGGTGGGGATGACGTCAAGTCATCATGGCCCTTACGTCCAGGGCTACACACGTGCTACAATGGCCACCACAAAGGGTCGCAATACCGTGAGGTGGAGCTAATCCCAAAAAGGTGGCCTCAGTTCGGATTGTAGTCTGCAACTCGACTACATGAAGTCGGAATCGCTAGTAATCGCGGATCAGAACGCCGCGGTGAATACAGTTCCCGGGCCTTGTACACACCGCCCGTCACACCACGAGAGCTGGTTGCGTTAGAAGTCGCCAGGCCAACCGCAAGGGGGCAGGCGCCGAATGCGTGATGAGTGATTGGGGT";
		Sequence seqt1 = new Sequence(index1, s1);
		Sequence seqt2 = new Sequence(index2, s2);
		//System.out.println(seqt1.getID());
		//System.out.println(seqt2.getID());
		seqt1.affiche();
		//seqt2.affiche();
		Alignement2seq AS = new Alignement2seq(seqt2, seqt2);
		AS.matriceDeScore();
		AS.aligner();
		System.out.println(AS.scoreAlignement());
		AS.afficher();
		*/
		
		/*
		String dMin = constAbr.distMin();
		System.out.println("*********************************************************************************************");
		System.out.println(dMin);
		*/
		
		/*
		List<String> test = new ArrayList<String>();
		test.add("hello");
		test.add(" ");
		test.add("toto");
		test.add(".");
		test.add("Je suis à l'ecole ");
		test.add("demain");
		
		for (String string : test) {
			System.out.print(string);
		}
		
		test.remove(3);
		
		System.out.println();
		for (String string : test) {
			System.out.print(string);
		}
		*/
		
		/*
		double ancienMat[][];
		ancienMat = new double [8][8];
		
		for (int i= 0; i<8; i++) {
			for(int j = i+1; j<8; j++) {
				ancienMat[i][j] = i+j;
				ancienMat[j][i] = i+j;
			}
		}
		
		for (int i= 0; i<ancienMat.length; i++) {
			for(int j = 0; j<ancienMat.length; j++) {
				System.out.print(ancienMat[i][j] + "    ");
			}
			System.out.println("");
		}
		
		System.out.println("*****************************************************************");
		
		double newMat[][] = suppressionLigneColMatrice(ancienMat, 0);
		for (int i= 0; i< newMat.length; i++) {
			for(int j = 0; j< newMat.length; j++) {
				System.out.print(newMat[i][j] + "    ");
			}
			System.out.println("");
		}
		System.out.println("*****************************************************************  ==  " + newMat.length);
		newMat = suppressionLigneColMatrice(newMat, 6);
		for (int i= 0; i< newMat.length; i++) {
			for(int j = 0; j< newMat.length; j++) {
				System.out.print(newMat[i][j] + "    ");
			}
			System.out.println("");
		}
		*/
		
		MatriceDistance mat = new MatriceDistance("ADN16S.fasta");
		mat = new MatriceDistance("test.fasta");
		mat.initMatriceDistance();
		
		
		Sequence seqt1 = mat.getListeDesSequences().get(0);
		Sequence seqt2 = mat.getListeDesSequences().get(1);
		
		Sequence seqt3 = mat.getListeDesSequences().get(2);
		Sequence seqt4 = mat.getListeDesSequences().get(3);
		
		Alignement AS1 = new Alignement(seqt1, seqt2);
		Alignement AS2 = new Alignement(seqt3, seqt4);
		AS1.aligner();
		System.out.println("*****************************************************************");
		AS1.afficher();
		
		AS2.aligner();
		System.out.println("*****************************************************************");
		AS2.afficher();
		System.out.println("*****************************************************************");
		
		Alignement AA2 = new Alignement(AS1, AS2);
		AA2.aligner();
		AA2.afficher();
		
		System.out.println("*****************************************************************");
		
		Alignement AA3 = new Alignement(AS1, seqt3);
		AA3.aligner();
		AA3.afficher();
		
		System.out.println("*****************************************************************");
		
		Alignement AA4 = new Alignement(AA3, seqt4);
		AA4.aligner();
		AA4.afficher();
		
		System.out.println("*****************************************************************");
		
		Alignement AA5 = new Alignement(AA4, AA2);
		AA5.aligner();
		AA5.afficher();
		
		System.out.println("*****************************************************************");
		
		/*Alignement2seq as1 = new Alignement2seq(seqt1, seqt2);
		as1.matriceDeScore();
		as1.aligner();
		as1.afficher();*/
		
		//System.out.println("*****************************************************************");
		
		//Communes.afficheMat(AS1.getMat());
		//System.out.println("*****************************************************************");
		//System.out.println(AS1.longueur());
		
		//Communes.afficheMat(AS2.getMat());
		//System.out.println("*****************************************************************");
		//System.out.println(AS2.longueur());
		
		
		/*
		Alignement2align AA = new Alignement2align(AS1, AS2);
		AA.matriceDeScore();
		
		
		
		//Communes.afficheMat(AA.getMat());
		
		System.out.println("");
		//System.out.println(AA.getMat().length);
		//System.out.println(AA.getMat()[0].length);
		
		AA.aligner();
		
		//System.out.println(AA.getMat().length);
		//Communes.afficheMat(AA.getMat());
		
		
		System.out.println("***************************************************************************************************************************************");
		
		AA.afficher();*/
		/*Communes.afficheMat(mat.getDistMat());
		
		ConstructionArbre constAbr = new ConstructionArbre(mat);
		constAbr.upgma();
		
		System.out.println("*****************************************************************");
		System.out.println("Nbre de feuilles de l'arbre : " + constAbr.getListeArbres().get(0).getNbreFeuilles());
		System.out.println("*****************************************************************");
		
		Communes.afficheMat(constAbr.getmD().getDistMat());*/
		
		// parcours de l'arbre :
		
		MatriceDistance mat = new MatriceDistance("ADN16S.fasta");
		mat.initMatriceDistance  ();
		ConstructionArbre A = new ConstructionArbre(mat);
		A.upgma();
		A.getListeArbres();
		Arbre B = A.getListeArbres().get(0);
		B.parcourArbre();
		System.out.print(A.getListeArbres().size());
		
	}
	
	
	/*
	String c2 = a2.colonne(i - 1);
	String c1 = a1.colonne(j - 1);
	for(int ii = 0; ii < c1.length(); ii++) {
		for(int jj = 0; jj < c2.length(); jj++) {
			if(c1.charAt(ii) == '-' || c2.charAt(jj) == '-') {
				//scoreNO = scoreNO + gap;
			}else {
				if(c1.charAt(ii) == c2.charAt(jj)) {
					scoreNO = scoreNO + match;
				}else {
					scoreNO = scoreNO + mismatch;
				}
			}
		}
	}
	//scoreNO = scoreNO /(a1.longueur() * a2.longueur());
	*/
	
	
	
	/*
	
	
	public static double[][] suppressionLigneColMatrice(double[][] tableau, int index, int diff) {
        int nRows = tableau.length;
        int nColumns = tableau[0].length;
 
        if (index >= nRows || index >= nColumns) {
            // Return exception ?
            return new double[0][0];
        }
 
        double[][] newTab = new double[nRows-1][nColumns-1];
        int newTabRow = 0;
        int newTabCol = 0;
 
        for(int i = 0 ; i<nRows ; ++i){
            if(i != index){
                for(int j = 0 ; j<nColumns ; ++j){
                    if(j != index){
                        newTab[newTabRow][newTabCol] = tableau[i][j];
                        ++newTabCol;
                    }
                }
                ++newTabRow;
                newTabCol = 0;
            }
        }
        return newTab;
    }
	
	public static double[][] suppressionLigneColMatrice(double[][] ancienMat, int index) {
		double[][] newTab = new double[ancienMat.length - 1][ancienMat.length - 1];
		int k = 0;
		
		if(index < ancienMat.length - 1) {
			for(int i = 0; i < ancienMat.length; i++) {
				if(i == index) {
					i++;
				}
				System.arraycopy(ancienMat[i], 0, newTab[k], 0, index);
				if (ancienMat[i].length != index) {
					System.arraycopy(ancienMat[i], index + 1, newTab[k], index, ancienMat[i].length - index - 1);
				}
				k++;
			}
		} else {
			for(int i = 0; i < ancienMat.length - 1; i++) {
				for(int j = i + 1; j < ancienMat.length - 1; j++) {
					newTab[i][j] = ancienMat[i][j];
					newTab[j][i] = ancienMat[j][i];
				}
			}
		}
		
		return newTab;
	}
	
	public static void calcMatrice(int lignmin, int colmin, double[][] tab){
		double ancienMat[][] = tab;
		
		// Suppression des lignes et colonnes correspondant à la distance minimale dans la matrice précédente
		double tempMat[][] = suppressionLigneColMatrice(ancienMat, lignmin);
		tempMat = suppressionLigneColMatrice(tempMat, colmin - 1);
		
		// Initialisation des dernières colonnes avant calcul des nouvelles distances
		double nouvMat[][] = new double[tempMat.length + 1][tempMat.length + 1];
		for(int i = 0; i < tempMat.length; i++) {
			for (int j = i + 1; j < tempMat.length; j++) {
				nouvMat[i][j] = tempMat[i][j];
				nouvMat[j][i] = tempMat[j][i];
			}
		}
		
		for (int i= 0; i<nouvMat.length; i++) {
			for(int j = 0; j<nouvMat.length; j++) {
				System.out.print(nouvMat[i][j] + "    ");
			}
			System.out.println("");
		}
		
		int j = tempMat.length - 1;
		int indexK = 0;
		for(int k = 0; k < nouvMat.length - 1 ; k++) {
			double dik = 0.0;
			double djk = 0.0;
			if (k < lignmin) {
				dik = ancienMat[indexK][lignmin];
				djk = ancienMat[indexK][colmin];
				System.out.println("dik = " + dik + " ===>  djk = " + djk);
				indexK++;
			}
			if (k == lignmin) {
				dik = ancienMat[indexK + 1][lignmin];
				djk = ancienMat[indexK + 1][colmin];
				System.out.println("dik = " + dik + " ===>  djk = " + djk);
				indexK = indexK + 2;
			}
			if (k > lignmin && k < colmin) {
				dik = ancienMat[indexK + 1][lignmin];
				djk = ancienMat[indexK + 1][colmin];
				System.out.println("dik = " + dik + " ===>  djk = " + djk);
				indexK++;
			}
			if (k == colmin) {
				dik = ancienMat[indexK + 1][lignmin];
				djk = ancienMat[indexK + 1][colmin];
				System.out.println("dik = " + dik + " ===>  djk = " + djk);
				indexK = indexK + 2;
			}
			if (k > colmin) {
				dik = ancienMat[indexK][lignmin];
				djk = ancienMat[indexK][colmin];
				System.out.println("dik = " + dik + " ===>  djk = " + djk);
				indexK++;
			}
		}
	}
	
	private void calcMatrice(int ligmin, int colmin, Arbre A, int doubll){
		try {
			double ancienMat[][] = this.mD.getDistMat();
			
			// Suppression des lignes et colonnes correspondant à la distance minimale dans la matrice précédente
			double tempMat[][] = suppressionLigneColMatrice(ancienMat, ligmin);
			tempMat = suppressionLigneColMatrice(tempMat, colmin - 1);
			
			int size = tempMat.length;
			System.out.println("Taille de la matrice apres suppression des lignes et colonnes : " + size);
			
			// Initialisation des dernières colonnes avant calcul des nouvelles distances
			double nouvMat[][] = new double[tempMat.length + 1][tempMat.length + 1];
			for(int i = 0; i < tempMat.length; i++) {
				for (int j = i + 1; j < tempMat.length; j++) {
					nouvMat[i][j] = tempMat[i][j];
					nouvMat[j][i] = tempMat[j][i];
				}
			}
			
			// Mise à jour de la liste des index de l'ancienne matrice pour matcher avec la nouvelle
			// Tableau des précédent index en fonction de la nouvelle matrice index correspond à nouvelle machine et valeur corresponds index ancienne matrice)
			List<Integer> tempList = this.mD.getListAncienIndexMatDist();
			tempList.remove(ligmin);
			tempList.remove(colmin - 1);
			tempList.add(tempList.size());
			this.mD.setListAncienIndexMatDist(tempList);
			
			System.out.print("Tableau des précédent index en fonction : ");
			for (Integer val : tempList) {
				System.out.print(val + " ");
			}
			System.out.println("");
			
			size = nouvMat.length;
			System.out.println("Taille de la matrice apres ajout ligne et colonne du bloc nouvellement forme : " + size);
			
			int j = nouvMat.length - 1;
			int indexK = 0;
			for(int k = 0; k < nouvMat.length - 1 ; k++) {
				double dik = 0.0;
				double djk = 0.0;
				double duk = 0.0;
				
				if (k < ligmin) {
					dik = ancienMat[indexK][ligmin];
					djk = ancienMat[indexK][colmin];
					System.out.println("indexK utilisé = " + (indexK) + "; i = " + ligmin + "; j = " + colmin);
					indexK++;
				}
				if (k == ligmin) {
					dik = ancienMat[indexK + 1][ligmin];
					djk = ancienMat[indexK + 1][colmin];
					System.out.println("indexK utilisé = " + (indexK+1) + "; i = " + ligmin + "; j = " + colmin);
					indexK = indexK + 2;
				}
				if (k > ligmin && k < colmin) {
					dik = ancienMat[indexK + 1][ligmin];
					djk = ancienMat[indexK + 1][colmin];
					System.out.println("indexK utilisé = " + (indexK+1) + "; i = " + ligmin + "; j = " + colmin);
					indexK++;
				}
				if (k == colmin) {
					dik = ancienMat[indexK + 1][ligmin];
					djk = ancienMat[indexK + 1][colmin];
					System.out.println("indexK utilisé = " + (indexK+1) + "; i = " + ligmin + "; j = " + colmin);
					indexK = indexK + 2;
				}
				if (k > colmin) {
					dik = ancienMat[indexK][ligmin];
					djk = ancienMat[indexK][colmin];
					System.out.println("indexK utilisé = " + (indexK) + "; i = " + ligmin + "; j = " + colmin);
					indexK++;
				}
				
				double ni = A.getGauche().getNbreFeuilles();
				double nj = A.getDroite().getNbreFeuilles();
				
				duk = ((ni / (ni + nj)) * dik) + ((nj / (ni + nj)) * djk);
				
				System.out.println("ni = " + ni + "; nj = " + nj + "; dik = " + dik + "; djk = " + djk + "; duk = " + duk + "; k = " + k + "; j = " + j);
				
				nouvMat[k][j] = duk;
				nouvMat[j][k] = duk;
			}
			
			this.mD.setDistMat(nouvMat);
		}
		catch(Exception ex) {
			throw ex;
		}
	}
	
	
	*/
}
